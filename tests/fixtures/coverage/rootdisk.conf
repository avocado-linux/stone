require-fwup-version="1.4.0"

# Environment Variables
#
# AVOCADO_SDK_RUNTIME_DIR:              (Required) Path to the images directory
# AVOCADO_IMAGE_BOOT:                   (Required) filename of the boot image
# AVOCADO_IMAGE_ROOTFS:                 (Required) filename of the rootfs image
# AVOCADO_IMAGE_VAR:                    (Required) filename of the var image
#
# Meta Data
# AVOCADO_OS_CODENAME:                  (Required) Codename of the OS
# AVOCADO_OS_DESCRIPTION:               (Required) Description of the OS
# AVOCADO_OS_VERSION:                   (Required) Version of the OS
# AVOCADO_OS_PLATFORM:                  (Required) Platform of the OS
# AVOCADO_OS_ARCHITECTURE:              (Required) Architecture of the OS
# AVOCADO_OS_AUTHOR:                    (Optional) Author of the OS
# AVOCADO_OS_VCS_IDENTIFIER:            (Optional) VCS identifier of the OS
# AVOCADO_OS_MISC:                      (Optional) Misc information about the OS
#
# Device Info
# AVOCADO_PARTITION_BLOCK_SIZE:         (Optional) Defaults to 512
#
# Uboot Environment
# AVOCADO_PARTITION_UBOOT_ENV_OFFSET:   (Required) Offset in blocks
# AVOCADO_PARTITION_UBOOT_ENV_OFFSET_REDUND:   (Required) Offset in blocks
# AVOCADO_PARTITION_UBOOT_ENV_BLOCKS:   (Required) Number of blocks
#
# Boot Partition
# AVOCADO_PARTITION_BOOTFS_OFFSET:      (Required) Offset in blocks
# AVOCADO_PARTITION_BOOTFS_BLOCKS:      (Required) Number of blocks
# AVOCADO_PARTITION_BOOTFS_TYPE:        (Optional) Defaults to 0xc
#
# Recovery Partition
# AVOCADO_PARTITION_RECOVERY_OFFSET:     (Required) Offset in blocks
# AVOCADO_PARTITION_RECOVERY_BLOCKS:     (Required) Number of blocks
# AVOCADO_PARTITION_RECOVERY_TYPE:       (Optional) Defaults to 0x83
#
# RootFS Partition
# AVOCADO_PARTITION_ROOTFS_OFFSET:      (Optional) Defaults to after boot_b
# AVOCADO_PARTITION_ROOTFS_BLOCKS:      (Required) Number of blocks
# AVOCADO_PARTITION_ROOTFS_TYPE:        (Optional) Defaults to 0x83
#
# Var Partition
# AVOCADO_PARTITION_VAR_OFFSET:         (Optional) Defaults to after rootfs_b
# AVOCADO_PARTITION_VAR_BLOCKS:         (Required) Number of blocks
# AVOCADO_PARTITION_VAR_EXPAND:         (Optional) Defaults to true
# AVOCADO_PARTITION_VAR_TYPE:           (Optional) Defaults to 0x83

define(UBOOT_ENV_OFFSET, "${AVOCADO_PARTITION_UBOOT_ENV_OFFSET}")
define(UBOOT_ENV_OFFSET_REDUND, "${AVOCADO_PARTITION_UBOOT_ENV_OFFSET_REDUND}")
define(UBOOT_ENV_BLOCKS, "${AVOCADO_PARTITION_UBOOT_ENV_BLOCKS}")
define(BLOCK_SIZE, "${AVOCADO_PARTITION_BLOCK_SIZE:-512}")

# Boot
define(BOOT_PART_TYPE, "${AVOCADO_PARTITION_BOOTFS_TYPE:-0xc}")
define(BOOT_A_PART_OFFSET, "${AVOCADO_PARTITION_BOOTFS_OFFSET}")
define(BOOT_A_PART_BLOCKS, "${AVOCADO_PARTITION_BOOTFS_BLOCKS}")
define-eval(BOOT_B_PART_OFFSET, "${BOOT_A_PART_OFFSET} + ${BOOT_A_PART_BLOCKS}")
define(BOOT_B_PART_BLOCKS, ${BOOT_A_PART_BLOCKS})

# Recovery
define(RECOVERY_PART_TYPE, "${AVOCADO_PARTITION_RECOVERY_TYPE:-0x83}")
define(RECOVERY_PART_OFFSET, "${AVOCADO_PARTITION_RECOVERY_OFFSET}")
define(RECOVERY_PART_BLOCKS, "${AVOCADO_PARTITION_RECOVERY_BLOCKS}")

# RootFS
define(ROOTFS_PART_TYPE, "${AVOCADO_PARTITION_ROOTFS_TYPE:-0x83}")
define(ROOTFS_A_PART_OFFSET, "${AVOCADO_PARTITION_ROOTFS_OFFSET}")
define(ROOTFS_A_PART_BLOCKS, "${AVOCADO_PARTITION_ROOTFS_BLOCKS}")
define-eval(ROOTFS_B_PART_OFFSET, "${ROOTFS_A_PART_OFFSET} + ${ROOTFS_A_PART_BLOCKS}")
define(ROOTFS_B_PART_BLOCKS, ${ROOTFS_A_PART_BLOCKS})

# Data
define-eval(VAR_PART_OFFSET, "${AVOCADO_PARTITION_VAR_OFFSET}")
define-eval(VAR_PART_BLOCKS, "${AVOCADO_PARTITION_VAR_BLOCKS}")
define(VAR_PART_EXPAND, "${AVOCADO_PARTITION_VAR_EXPAND:-true}")
define(VAR_PART_TYPE, "${AVOCADO_PARTITION_VAR_TYPE:-0x83}")
# Firmware archive metadata
meta-product = ${AVOCADO_OS_CODENAME}
meta-description = ${AVOCADO_OS_DESCRIPTION}
meta-version = ${AVOCADO_OS_VERSION}
meta-platform = ${AVOCADO_OS_PLATFORM}
meta-architecture = ${AVOCADO_OS_ARCHITECTURE}
meta-author = ${AVOCADO_OS_AUTHOR}
meta-vcs-identifier = ${AVOCADO_OS_VCS_IDENTIFIER}
meta-misc = ${AVOCADO_OS_MISC}

mbr mbr-a {
    partition 0 {
        block-offset = ${BOOT_A_PART_OFFSET}
        block-count = ${BOOT_A_PART_BLOCKS}
        type = ${BOOT_PART_TYPE}
        boot = true
    }
    partition 1 {
        block-offset = ${ROOTFS_A_PART_OFFSET}
        block-count = ${ROOTFS_A_PART_BLOCKS}
        type = ${ROOTFS_PART_TYPE}
    }
    partition 2 {
        block-offset = ${VAR_PART_OFFSET}
        block-count = ${VAR_PART_BLOCKS}
        type = ${VAR_PART_TYPE}
        expand = ${VAR_PART_EXPAND}
    }
}

mbr mbr-b {
    partition 0 {
        block-offset = ${BOOT_B_PART_OFFSET}
        block-count = ${BOOT_B_PART_BLOCKS}
        type = ${BOOT_PART_TYPE}
        boot = true
    }
    partition 1 {
        block-offset = ${ROOTFS_B_PART_OFFSET}
        block-count = ${ROOTFS_B_PART_BLOCKS}
        type = ${ROOTFS_PART_TYPE}
    }
    partition 2 {
        block-offset = ${VAR_PART_OFFSET}
        block-count = ${VAR_PART_BLOCKS}
        type = ${VAR_PART_TYPE}
        expand = ${VAR_PART_EXPAND}
    }
}

mbr recovery {
    partition 0 {
        block-offset = ${RECOVERY_PART_OFFSET}
        block-count = ${RECOVERY_PART_BLOCKS}
        type = ${RECOVERY_PART_TYPE}
    }
    partition 1 {
        block-offset = ${ROOTFS_A_PART_OFFSET}
        block-count = ${ROOTFS_A_PART_BLOCKS}
        type = ${ROOTFS_PART_TYPE}
    }
    partition 2 {
        block-offset = ${VAR_PART_OFFSET}
        block-count = ${VAR_PART_BLOCKS}
        type = ${VAR_PART_TYPE}
        expand = ${VAR_PART_EXPAND}
    }
}

# Location where installed firmware information is stored.
# While this is called "u-boot", u-boot isn't involved in this
# setup. It just provides a convenient key/value store format.
uboot-environment uboot-env {
    block-offset = ${UBOOT_ENV_OFFSET}
    block-offset-redund = ${UBOOT_ENV_OFFSET_REDUND}
    block-count = ${UBOOT_ENV_BLOCKS}
}
file-resource uboot_env.img {
    host-path = "${AVOCADO_SDK_RUNTIME_DIR}/${AVOCADO_IMAGE_UBOOT_ENV}"
    assert-size-lte = ${UBOOT_ENV_BLOCKS}
}
file-resource boot.img {
    host-path = "${AVOCADO_SDK_RUNTIME_DIR}/${AVOCADO_IMAGE_BOOT}"
    assert-size-lte = ${BOOT_A_PART_BLOCKS}
}
file-resource rootfs.img {
    host-path = "${AVOCADO_SDK_RUNTIME_DIR}/${AVOCADO_IMAGE_ROOTFS}"
    assert-size-lte = ${ROOTFS_A_PART_BLOCKS}
}
file-resource var.img {
    host-path = "${AVOCADO_SDK_RUNTIME_DIR}/${AVOCADO_IMAGE_VAR}"
    assert-size-lte = ${VAR_PART_BLOCKS}
}

# This firmware task writes everything to the destination media.
# This should only be run for the first installation.
task complete {
    # Only match if not mounted
    require-unmounted-destination = true

    on-init {
        mbr_write(mbr-a)
    }

    on-resource uboot_env.img { raw_write(${UBOOT_ENV_OFFSET}) }
    on-resource boot.img { raw_write(${BOOT_A_PART_OFFSET}) }
    on-resource rootfs.img { raw_write(${ROOTFS_A_PART_OFFSET}) }
    on-resource var.img { raw_write(${VAR_PART_OFFSET}) }

    on-finish {
        uboot_setenv(uboot-env, "avocado_boot_slot", "a")
        uboot_setenv(uboot-env, "a.avo_part_boot_offset", "${BOOT_A_PART_OFFSET}")
        uboot_setenv(uboot-env, "a.avo_part_boot_blocks", "${BOOT_A_PART_BLOCKS}")
        uboot_setenv(uboot-env, "a.avo_part_boot_type", "${BOOT_PART_TYPE}")
        uboot_setenv(uboot-env, "a.avo_part_rootfs_offset", "${ROOTFS_A_PART_OFFSET}")
        uboot_setenv(uboot-env, "a.avo_part_rootfs_blocks", "${ROOTFS_A_PART_BLOCKS}")
        uboot_setenv(uboot-env, "a.avo_part_rootfs_type", "${ROOTFS_PART_TYPE}")
        uboot_setenv(uboot-env, "a.avo_part_var_offset", "${VAR_PART_OFFSET}")
        uboot_setenv(uboot-env, "a.avo_part_var_blocks", "${VAR_PART_BLOCKS}")
        uboot_setenv(uboot-env, "a.avo_part_var_type", "${VAR_PART_TYPE}")

        # Clear out any old data in the B partition that might be mistaken for
        # a file system. This is mostly to avoid confusion in humans when
        # reprogramming SDCards with unknown contents.
        raw_memset(${BOOT_B_PART_OFFSET}, 256, 0xff)
        raw_memset(${ROOTFS_B_PART_OFFSET}, 256, 0xff)
    }
}

task upgrade.a {
    # This task upgrades the A partition, so make sure we're running
    # on B.
    require-uboot-variable(uboot-env, "avocado_boot_slot", "b")

    # Verify the expected platform/architecture
    require-uboot-variable(uboot-env, "b.avocado_platform", "${AVOCADO_OS_PLATFORM}")
    require-uboot-variable(uboot-env, "b.avocado_architecture", "${AVOCADO_OS_ARCHITECTURE}")

    on-init {
        info("Upgrading boot slot A")

        # Clear some firmware information just in case this update gets
        # interrupted midway. If this partition was bootable, it's not going to
        # be soon.
        uboot_unsetenv(uboot-env, "a.avocado_version")
        uboot_unsetenv(uboot-env, "a.avocado_platform")
        uboot_unsetenv(uboot-env, "a.avocado_architecture")
        uboot_unsetenv(uboot-env, "a.avocado_uuid")

        trim(${ROOTFS_A_PART_OFFSET}, ${ROOTFS_A_PART_BLOCKS})
    }

    on-resource boot.img {
      delta-source-raw-offset=${BOOT_B_PART_OFFSET}
      delta-source-raw-count=${BOOT_B_PART_BLOCKS}
      raw_write(${BOOT_A_PART_OFFSET})
    }

    on-resource rootfs.img {
      delta-source-raw-offset=${ROOTFS_B_PART_OFFSET}
      delta-source-raw-count=${ROOTFS_B_PART_BLOCKS}
      raw_write(${ROOTFS_A_PART_OFFSET})
    }

    on-finish {
        # Reset the validation status and boot to A
        uboot_setenv(uboot-env, "avocado_boot_slot", "a")
        mbr_write(mbr-a)
    }
}

task upgrade.b {
    # This task upgrades the B partition, so make sure we're running
    # on A.
    require-uboot-variable(uboot-env, "avocado_boot_slot", "a")

    # Verify the expected platform/architecture
    require-uboot-variable(uboot-env, "a.avocado_platform", "${AVOCADO_OS_PLATFORM}")
    require-uboot-variable(uboot-env, "a.avocado_architecture", "${AVOCADO_OS_ARCHITECTURE}")

    on-init {
      info("Upgrading boot slot B")

      # Clear some firmware information just in case this update gets
      # interrupted midway.
      uboot_unsetenv(uboot-env, "b.avocado_version")
      uboot_unsetenv(uboot-env, "b.avocado_platform")
      uboot_unsetenv(uboot-env, "b.avocado_architecture")
      uboot_unsetenv(uboot-env, "b.avocado_uuid")

      trim(${ROOTFS_B_PART_OFFSET}, ${ROOTFS_B_PART_BLOCKS})
    }

    on-resource boot.img {
      delta-source-raw-offset=${BOOT_A_PART_OFFSET}
      delta-source-raw-count=${BOOT_A_PART_BLOCKS}
      raw_write(${BOOT_B_PART_OFFSET})
    }

    on-resource rootfs.img {
      delta-source-raw-offset=${ROOTFS_A_PART_OFFSET}
      delta-source-raw-count=${ROOTFS_A_PART_BLOCKS}
      raw_write(${ROOTFS_B_PART_OFFSET})
    }

    on-finish {
        # Reset the validation status and boot to B next time.
        uboot_setenv(uboot-env, "avocado_boot_slot", "b")
        mbr_write(mbr-b)
    }
}

task upgrade.wrong {
    require-uboot-variable(uboot-env, "a.avocado_platform", "${AVOCADO_OS_PLATFORM}")
    require-uboot-variable(uboot-env, "a.avocado_architecture", "${AVOCADO_OS_ARCHITECTURE}")
    on-init {
        error("Please check the media being upgraded. It doesn't look like either the A or B boot slots are active.")
    }
}

task upgrade.wrongplatform {
    on-init {
        error("Expecting platform=${AVOCADO_OS_PLATFORM} and architecture=${AVOCADO_OS_ARCHITECTURE}")
    }
}
